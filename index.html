<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>BanG Dream! åå®¹é“</title>
    <meta name="description" content="BanG Dream! ä¸»é¢˜åå®¹é“ç›Šæ™ºæ¸¸æˆï¼" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #4a6741;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        user-select: none;
        -webkit-user-select: none;
        overflow: hidden;
      }

      #game-wrapper {
        position: relative;
      }

      #game-wrapper img.board-bg {
        display: block;
        width: 960px;
        height: 540px;
        pointer-events: none;
      }

      /* æ£‹ç›˜ç½‘æ ¼åŒºåŸŸ â€” åŸºäº board.png åƒç´ æµ‹é‡ */
      #board {
        position: absolute;
        top: 4.8%;
        left: 25.3%;
        width: 49.5%;
        height: 89.5%;
        overflow: hidden;
      }

      .block {
        position: absolute;
        cursor: grab;
        transition:
          left 0.18s ease-out,
          top 0.18s ease-out;
        border-radius: 6px;
        overflow: hidden;
        z-index: 1;
      }

      .block.dragging {
        transition: none;
        cursor: grabbing;
        z-index: 50;
        filter: brightness(1.05);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }

      .block:hover {
        z-index: 10;
        filter: brightness(1.08);
      }

      .block:active {
        cursor: grabbing;
      }

      .block img {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
        pointer-events: none;
      }

      /* æ§åˆ¶é¢æ¿ â€” å³ä¾§ */
      #control-panel {
        position: absolute;
        top: 50%;
        right: 2%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        z-index: 20;
      }

      #step-label {
        color: #c4a96a;
        font-size: 14px;
        font-weight: bold;
        letter-spacing: 1px;
      }

      #step-display {
        color: #e8b74a;
        font-size: 52px;
        font-weight: 900;
        font-family: "Courier New", monospace;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      .btn {
        padding: 8px 20px;
        border: 2px solid #e8b74a;
        background: rgba(0, 0, 0, 0.6);
        color: #e8b74a;
        font-size: 14px;
        font-weight: bold;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        font-family: "Microsoft YaHei", sans-serif;
        width: 90px;
        text-align: center;
      }

      .btn:hover {
        background: #e8b74a;
        color: #1a1a1a;
      }

      .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Victory overlay */
      #victory-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 100;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s ease;
      }

      #victory-overlay.show {
        display: flex;
      }

      #victory-box {
        background: linear-gradient(135deg, #ff6b9d, #c44569);
        border: 4px solid #fff;
        border-radius: 20px;
        padding: 40px 50px;
        text-align: center;
        color: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: popIn 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
      }

      #victory-box h2 {
        font-size: 36px;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      #victory-box p {
        font-size: 20px;
        margin-bottom: 24px;
        opacity: 0.9;
      }

      #victory-box .btn {
        font-size: 16px;
        padding: 10px 28px;
        border-color: #fff;
        color: #fff;
        background: rgba(255, 255, 255, 0.15);
        width: auto;
      }

      #victory-box .btn:hover {
        background: #fff;
        color: #c44569;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes popIn {
        from {
          transform: scale(0.5);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Responsive */
      @media (max-width: 780px) {
        #game-wrapper img.board-bg {
          width: 100vw;
          height: auto;
        }
        #control-panel {
          position: absolute;
          top: auto;
          bottom: -50px;
          right: 50%;
          transform: translateX(50%);
          flex-direction: row;
          gap: 16px;
        }
        #step-label {
          display: none;
        }
        #step-display {
          font-size: 28px;
        }
        .btn {
          font-size: 13px;
          padding: 6px 14px;
          width: auto;
        }
        #github-star {
          padding: 6px;
          font-size: 0;
          gap: 0;
          border-radius: 50%;
        }
        #github-star svg {
          width: 16px;
          height: 16px;
        }
        #github-star .star-icon {
          display: none;
        }
      }
      #github-star {
        position: absolute;
        top: 8px;
        right: 2%;
        z-index: 200;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.6);
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        text-decoration: none;
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        transition: all 0.25s ease;
        backdrop-filter: blur(6px);
      }

      #github-star:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: #e8b74a;
        color: #e8b74a;
        transform: scale(1.05);
      }

      #github-star svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }

      #github-star .star-icon {
        width: 14px;
        height: 14px;
      }
    </style>
  </head>
  <body>
    <div id="game-wrapper">
      <img class="board-bg" src="images/board.png" alt="æ£‹ç›˜èƒŒæ™¯" />

      <a
        id="github-star"
        href="https://github.com/fflow2023/BanGKlotski"
        target="_blank"
        rel="noopener"
      >
        <svg viewBox="0 0 16 16">
          <path
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          />
        </svg>
        <svg class="star-icon" viewBox="0 0 16 16">
          <path
            d="M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25z"
          />
        </svg>
        Star
      </a>

      <div id="board"></div>

      <div id="control-panel">
        <div id="step-label">æ­¥ æ•°</div>
        <div id="step-display">0</div>
        <button class="btn" id="btn-reset" onclick="resetGame()">é‡ ç½®</button>
        <button class="btn" id="btn-hint" onclick="getHint()">æ ç¤º</button>
      </div>
    </div>

    <div id="victory-overlay">
      <div id="victory-box">
        <h2>ğŸ‰ é€šå…³æˆåŠŸï¼</h2>
        <p>ç±³æ­‡å°”æˆåŠŸé€ƒå‡ºï¼ç”¨äº† <span id="victory-steps">0</span> æ­¥</p>
        <button class="btn" onclick="resetGame()">å†æ¥ä¸€å±€</button>
      </div>
    </div>

    <script>
      // ============================================================
      // æ•°æ®æ¨¡å‹
      // ============================================================
      const COLS = 4;
      const ROWS = 5;
      // æ–¹å—ä¹‹é—´çš„é—´è· (px)
      const GAP = 2;

      // æ–¹å—ç±»å‹: [å®½, é«˜]
      const TYPES = {
        "2x2": [2, 2],
        "1x2": [1, 2],
        "2x1": [2, 1],
        "1x1": [1, 1],
      };

      // åˆå§‹å¸ƒå±€ â€” å‚ç…§æ•ˆæœå›¾
      const INITIAL_LAYOUT = [
        { id: "michelle", type: "2x2", x: 1, y: 0, img: "images/michelle.png" },
        { id: "nyamu", type: "1x2", x: 0, y: 0, img: "images/nyamu.png" },
        { id: "moca", type: "1x2", x: 3, y: 0, img: "images/moca.png" },
        { id: "arisa", type: "1x2", x: 0, y: 2, img: "images/arisa.png" },
        { id: "yukina", type: "2x1", x: 1, y: 2, img: "images/yukina.png" },
        { id: "eve", type: "1x2", x: 3, y: 2, img: "images/eve.png" },
        { id: "saya", type: "1x1", x: 1, y: 3, img: "images/saya.png" },
        { id: "box", type: "1x1", x: 2, y: 3, img: "images/box.png" },
        { id: "otae", type: "1x1", x: 0, y: 4, img: "images/otae.png" },
        { id: "tsukushi", type: "1x1", x: 3, y: 4, img: "images/tsukushi.png" },
      ];

      // å½“å‰æ¸¸æˆçŠ¶æ€
      let blocks = [];
      let steps = 0;
      let solving = false;

      // æç¤ºç³»ç»ŸçŠ¶æ€
      let hintSolution = null; // ç¼“å­˜çš„è§£é¢˜è·¯å¾„
      let hintIndex = 0; // å½“å‰æç¤ºåˆ°ç¬¬å‡ æ­¥
      let hintStateKey = null; // ç¼“å­˜å¯¹åº”çš„çŠ¶æ€
      let hintWorker = null; // Web Worker å¼•ç”¨
      let hintComputing = false;

      // æ‹–æ‹½çŠ¶æ€
      let dragState = null;

      // DOM å¼•ç”¨
      const boardEl = document.getElementById("board");
      const stepDisplay = document.getElementById("step-display");
      const victoryOverlay = document.getElementById("victory-overlay");
      const victorySteps = document.getElementById("victory-steps");

      // ============================================================
      // æ¸²æŸ“
      // ============================================================
      function deepCloneLayout(layout) {
        return layout.map((b) => ({ ...b }));
      }

      function getCellSize() {
        const boardRect = boardEl.getBoundingClientRect();
        return {
          cellW: boardRect.width / COLS,
          cellH: boardRect.height / ROWS,
        };
      }

      function renderBoard() {
        boardEl.innerHTML = "";
        const { cellW, cellH } = getCellSize();

        blocks.forEach((block) => {
          const [w, h] = TYPES[block.type];
          const el = document.createElement("div");
          el.className = "block";
          el.id = "block-" + block.id;
          el.style.width = cellW * w - GAP * 2 + "px";
          el.style.height = cellH * h - GAP * 2 + "px";
          el.style.left = block.x * cellW + GAP + "px";
          el.style.top = block.y * cellH + GAP + "px";

          const img = document.createElement("img");
          img.src = block.img;
          img.alt = block.id;
          img.draggable = false;
          el.appendChild(img);

          // é¼ æ ‡æ‹–æ‹½
          el.addEventListener("mousedown", (e) => {
            e.preventDefault();
            startDrag(block.id, e.clientX, e.clientY);
          });

          // è§¦æ‘¸æ‹–æ‹½
          el.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            startDrag(block.id, touch.clientX, touch.clientY);
          });

          boardEl.appendChild(el);
        });
      }

      function updateBlockPosition(block) {
        const { cellW, cellH } = getCellSize();
        const el = document.getElementById("block-" + block.id);
        if (!el) return;
        el.style.left = block.x * cellW + GAP + "px";
        el.style.top = block.y * cellH + GAP + "px";
      }

      // ============================================================
      // æ‹–æ‹½äº¤äº’
      // ============================================================
      function startDrag(blockId, startX, startY) {
        if (solving) return;
        const block = blocks.find((b) => b.id === blockId);
        if (!block) return;

        const el = document.getElementById("block-" + blockId);
        el.classList.add("dragging");

        dragState = {
          blockId,
          startX,
          startY,
          origGridX: block.x,
          origGridY: block.y,
          moved: false,
        };
      }

      function onDragMove(clientX, clientY) {
        if (!dragState) return;

        const { cellW, cellH } = getCellSize();
        const dx = clientX - dragState.startX;
        const dy = clientY - dragState.startY;

        // éœ€è¦æ»‘åŠ¨è¶…è¿‡åŠæ ¼æ‰è§¦å‘ç§»åŠ¨
        const threshold = Math.min(cellW, cellH) * 0.2;

        if (dragState.moved) return; // å·²ç»è§¦å‘è¿‡ç§»åŠ¨äº†

        let moveDx = 0;
        let moveDy = 0;

        if (Math.abs(dx) > Math.abs(dy)) {
          // æ°´å¹³æ‹–æ‹½
          if (dx > threshold) moveDx = 1;
          else if (dx < -threshold) moveDx = -1;
        } else {
          // å‚ç›´æ‹–æ‹½
          if (dy > threshold) moveDy = 1;
          else if (dy < -threshold) moveDy = -1;
        }

        if (moveDx !== 0 || moveDy !== 0) {
          const success = moveBlock(dragState.blockId, moveDx, moveDy);
          if (success) {
            dragState.moved = true;
          }
        }
      }

      function endDrag() {
        if (!dragState) return;
        const el = document.getElementById("block-" + dragState.blockId);
        if (el) el.classList.remove("dragging");
        dragState = null;
      }

      // å…¨å±€é¼ æ ‡äº‹ä»¶
      document.addEventListener("mousemove", (e) => {
        onDragMove(e.clientX, e.clientY);
      });

      document.addEventListener("mouseup", () => {
        endDrag();
      });

      // å…¨å±€è§¦æ‘¸äº‹ä»¶
      document.addEventListener(
        "touchmove",
        (e) => {
          if (dragState) {
            e.preventDefault();
            const touch = e.touches[0];
            onDragMove(touch.clientX, touch.clientY);
          }
        },
        { passive: false },
      );

      document.addEventListener("touchend", () => {
        endDrag();
      });

      document.addEventListener("touchcancel", () => {
        endDrag();
      });

      // ============================================================
      // éŸ³æ•ˆ (Web Audio API)
      // ============================================================
      let audioCtx = null;

      function playMoveSound() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t = audioCtx.currentTime;

        const rand = (base, range) => base + (Math.random() - 0.5) * 2 * range;

        const bufLen = Math.floor(audioCtx.sampleRate * 0.04);
        const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;

        const noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        const bandpass = audioCtx.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.value = rand(2200, 300);
        bandpass.Q.value = rand(3.0, 0.8);

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(rand(0.35, 0.05), t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

        noise.connect(bandpass);
        bandpass.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start(t);

        // å±‚2: ä½é¢‘æ­£å¼¦è„‰å†² â†’ æœ¨å¤´ç¢°æ’çš„"å“’"
        const osc = audioCtx.createOscillator();
        const oscGain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(rand(350, 40), t);
        osc.frequency.exponentialRampToValueAtTime(rand(150, 20), t + 0.05);
        oscGain.gain.setValueAtTime(rand(0.2, 0.03), t);
        oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);

        osc.connect(oscGain);
        oscGain.connect(audioCtx.destination);
        osc.start(t);
        osc.stop(t + 0.06);
      }

      // ============================================================
      // ç¢°æ’æ£€æµ‹ä¸ç§»åŠ¨
      // ============================================================

      // æ„å»º 4x5 å ç”¨ç½‘æ ¼
      function buildGrid(blocksState) {
        const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        blocksState.forEach((b) => {
          const [w, h] = TYPES[b.type];
          for (let dy = 0; dy < h; dy++) {
            for (let dx = 0; dx < w; dx++) {
              grid[b.y + dy][b.x + dx] = b.id;
            }
          }
        });
        return grid;
      }

      function canMove(block, dx, dy, grid) {
        const [w, h] = TYPES[block.type];
        const nx = block.x + dx;
        const ny = block.y + dy;

        // è¾¹ç•Œæ£€æµ‹
        if (nx < 0 || ny < 0 || nx + w > COLS || ny + h > ROWS) return false;

        // ç¢°æ’æ£€æµ‹ï¼šæ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦è¢«å…¶ä»–æ–¹å—å æ®
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            const targetR = ny + r;
            const targetC = nx + c;
            const occupant = grid[targetR][targetC];
            if (occupant !== null && occupant !== block.id) return false;
          }
        }
        return true;
      }

      function moveBlock(blockId, dx, dy) {
        const block = blocks.find((b) => b.id === blockId);
        if (!block) return false;

        const grid = buildGrid(blocks);
        if (!canMove(block, dx, dy, grid)) return false;

        block.x += dx;
        block.y += dy;
        updateBlockPosition(block);
        playMoveSound();

        if (!solving) {
          // ç”¨æˆ·æ‰‹åŠ¨ç§»åŠ¨ï¼Œä½¿æç¤ºç¼“å­˜å¤±æ•ˆ
          hintSolution = null;
          hintIndex = 0;
          hintStateKey = null;
          steps++;
          stepDisplay.textContent = steps;
        }

        // èƒœåˆ©åˆ¤å®š
        if (block.id === "michelle" && block.x === 1 && block.y === 3) {
          setTimeout(showVictory, 300);
        }

        return true;
      }

      // ============================================================
      // èƒœåˆ©
      // ============================================================
      function showVictory() {
        victorySteps.textContent = steps;
        victoryOverlay.classList.add("show");
      }

      // ============================================================
      // é‡ç½®
      // ============================================================
      function resetGame() {
        solving = false;
        steps = 0;
        stepDisplay.textContent = "0";
        victoryOverlay.classList.remove("show");
        blocks = deepCloneLayout(INITIAL_LAYOUT);
        hintSolution = null;
        hintIndex = 0;
        hintStateKey = null;
        hintComputing = false;
        if (hintWorker) {
          hintWorker.terminate();
          hintWorker = null;
        }
        const btnHint = document.getElementById("btn-hint");
        if (btnHint) {
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";
        }
        renderBoard();
      }

      // ============================================================
      // æç¤ºç³»ç»Ÿ (Web Worker BFS)
      // ============================================================

      // Web Worker æºç  â€” ä½¿ç”¨ç±»å‹ç¼–ç è¿›è¡Œé«˜æ•ˆ BFS
      // å…³é”®ä¼˜åŒ–ï¼šåŒç±»å‹æ–¹å—è§†ä¸ºç­‰ä»·ï¼Œåªæœ‰ michelle ä½¿ç”¨ç‹¬ç«‹æ ‡è¯†
      // è¿™å°†çŠ¶æ€ç©ºé—´ä»æ•°ç™¾ä¸‡é™åˆ°çº¦ 25,000
      const workerCode = `
        const COLS = 4, ROWS = 5;
        const TYPES = { '2x2': [2,2], '1x2': [1,2], '2x1': [2,1], '1x1': [1,1] };
        // ç±»å‹ç¼–ç : 0=ç©º, 1=1x1, 2=1x2(å ä¸ŠåŠ), 3=1x2(å ä¸‹åŠ), 4=2x1(å å·¦åŠ), 5=2x1(å å³åŠ),
        //           6=michelleå·¦ä¸Š, 7=michelleå³ä¸Š, 8=michelleå·¦ä¸‹, 9=michelleå³ä¸‹

        function encodeState(bs) {
          const g = new Uint8Array(20);
          for (const b of bs) {
            const [w, h] = TYPES[b.type];
            if (b.id === 'michelle') {
              g[b.y * COLS + b.x] = 6;
              g[b.y * COLS + b.x + 1] = 7;
              g[(b.y + 1) * COLS + b.x] = 8;
              g[(b.y + 1) * COLS + b.x + 1] = 9;
            } else if (b.type === '1x1') {
              g[b.y * COLS + b.x] = 1;
            } else if (b.type === '1x2') {
              g[b.y * COLS + b.x] = 2;
              g[(b.y + 1) * COLS + b.x] = 3;
            } else if (b.type === '2x1') {
              g[b.y * COLS + b.x] = 4;
              g[b.y * COLS + b.x + 1] = 5;
            }
          }
          return String.fromCharCode.apply(null, g);
        }

        function buildGrid(bs) {
          const grid = [];
          for (let r = 0; r < ROWS; r++) grid[r] = new Array(COLS).fill(-1);
          for (let i = 0; i < bs.length; i++) {
            const b = bs[i];
            const [w, h] = TYPES[b.type];
            for (let dy = 0; dy < h; dy++)
              for (let dx = 0; dx < w; dx++)
                grid[b.y + dy][b.x + dx] = i;
          }
          return grid;
        }

        function canMove(b, dx, dy, grid, idx) {
          const [w, h] = TYPES[b.type];
          const nx = b.x + dx, ny = b.y + dy;
          if (nx < 0 || ny < 0 || nx + w > COLS || ny + h > ROWS) return false;
          for (let r = 0; r < h; r++)
            for (let c = 0; c < w; c++) {
              const occ = grid[ny + r][nx + c];
              if (occ !== -1 && occ !== idx) return false;
            }
          return true;
        }

        self.onmessage = function(e) {
          const startBlocks = e.data;
          const visited = new Set();
          const startKey = encodeState(startBlocks);
          visited.add(startKey);

          const queue = [startBlocks.map(b => ({...b}))];
          const parent = [null];
          let head = 0;

          const dirs = [[0,-1],[0,1],[-1,0],[1,0]];

          while (head < queue.length) {
            const state = queue[head];
            const michIdx = state.findIndex(b => b.id === 'michelle');

            if (state[michIdx].x === 1 && state[michIdx].y === 3) {
              const path = [];
              let cur = head;
              while (parent[cur] !== null) {
                const p = parent[cur];
                path.unshift({ id: queue[p.stateIdx][p.blockIdx].id, dx: p.dx, dy: p.dy });
                cur = p.stateIdx;
              }
              self.postMessage({ success: true, moves: path });
              return;
            }

            const grid = buildGrid(state);

            for (let bi = 0; bi < state.length; bi++) {
              const b = state[bi];
              for (const [dx, dy] of dirs) {
                if (!canMove(b, dx, dy, grid, bi)) continue;
                const ns = state.map(x => ({...x}));
                ns[bi] = {...ns[bi], x: ns[bi].x + dx, y: ns[bi].y + dy};
                const key = encodeState(ns);
                if (visited.has(key)) continue;
                visited.add(key);
                queue.push(ns);
                parent.push({ stateIdx: head, blockIdx: bi, dx, dy });
              }
            }
            head++;
          }

          self.postMessage({ success: false });
        };
      `;

      function getHint() {
        if (solving || hintComputing) return;

        const btnHint = document.getElementById("btn-hint");

        // å¦‚æœæœ‰ç¼“å­˜çš„è§£ä¸”è¿˜æœ‰åç»­æ­¥éª¤ï¼Œç›´æ¥æ‰§è¡Œ
        if (hintSolution && hintIndex < hintSolution.length) {
          const move = hintSolution[hintIndex];
          // æ ‡è®°ä¸º solving ä»¥é¿å…æ¸…é™¤ç¼“å­˜
          solving = true;
          moveBlock(move.id, move.dx, move.dy);
          steps++;
          stepDisplay.textContent = steps;
          solving = false;
          hintIndex++;
          if (hintIndex >= hintSolution.length) {
            hintSolution = null;
            hintStateKey = null;
          }
          return;
        }

        // éœ€è¦é‡æ–°è®¡ç®—
        hintComputing = true;
        btnHint.disabled = true;
        btnHint.textContent = "æ€è€ƒä¸­â€¦";

        const blob = new Blob([workerCode], { type: "application/javascript" });
        const url = URL.createObjectURL(blob);
        hintWorker = new Worker(url);

        hintWorker.onmessage = function (e) {
          URL.revokeObjectURL(url);
          hintWorker = null;
          hintComputing = false;
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";

          if (e.data.success && e.data.moves.length > 0) {
            hintSolution = e.data.moves;
            hintIndex = 0;
            // ç«‹å³æ‰§è¡Œç¬¬ä¸€æ­¥
            const move = hintSolution[hintIndex];
            solving = true;
            moveBlock(move.id, move.dx, move.dy);
            steps++;
            stepDisplay.textContent = steps;
            solving = false;
            hintIndex++;
            if (hintIndex >= hintSolution.length) {
              hintSolution = null;
              hintStateKey = null;
            }
          }
        };

        hintWorker.onerror = function () {
          URL.revokeObjectURL(url);
          hintWorker = null;
          hintComputing = false;
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";
          alert("æ±‚è§£å‡ºé”™ï¼Œè¯·é‡è¯•");
        };

        // å‘é€å½“å‰çŠ¶æ€ç»™ Worker
        hintWorker.postMessage(deepCloneLayout(blocks));
      }

      // ============================================================
      // å¯åŠ¨
      // ============================================================
      window.addEventListener("load", () => {
        resetGame();
      });

      window.addEventListener("resize", () => {
        renderBoard();
      });
    </script>
  </body>
</html>
